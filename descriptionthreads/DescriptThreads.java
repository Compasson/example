package descriptionthreads;

import java.io.File;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

/**
 *          СОЗДАНИЕ ПОТОКОВ
 *               
 *               Чтобы создать поток надо выполнить 5 пунктов:
 *     
 *          1)  В тело метода run() ввести код исполняемой задачи. У интерфеса Runnable один единственный метод.
 *          2)  Создать класс реализующий интерфейс Runnable
 *          3)  Сконструировать обьект нашего класса
 *          4)  Сконструировать обьект типа Thread из обьекта нашего класса
 *          5)  Запустить поток методом start()
 *          
 *          
 *               Для Java 8 поток создать еще проще(при помощи лямда выражений):
 *               
 *                      Runnable r = () -> {
 *                      
 *                          ...код потока...
 *                      };  
 *          
 *               
 *          ПРЕРЫВАНИЕ ПОТОКОВ
 *          
 *               Поток прерывается когда метод run() возвращает управление выполнив метод return() вслед за последним оператором в своем теле
 *                     или  если возникает исключение, которое не перехватывается в данном методе.
 *                     
 *               Прерыванеие потока ПРИНУДИТЕЛЬНО. Метод interrupt() может вызываться только ЗАПРОСА состояния потока.
 *                     Когда вызывается метод interupt(), то устанавливается СОСТОЯНИЕ ПРЕРЫВАНИЯ ПОТОКА. Это признак типа boolean у каждого потока.
 *                     
 *                     Поток проверяется 2-мя случаями:
 *                     
 *                           1)  Если поток не заблокирован. Вызывается текущий поток методом currentThread() и вызывающий далее метод isInerrupted().
 *                               
 *                               while (!Thread.currentThread().isInterrupted() && Дополнительные действия)
 *                               {
 *                                     дополнительные действия
 *                               }
 *                            
 *                           2) Если поток заблокирован (sleep() или wait()), то проверить его состояние нельзя. 
 *                                    В этом случае на помощь приходит исключение IntrruptedException
 *                                    
 *                      Исключение InterruptedEException нельзя ИГНОРИРОВАТЬ!!! Есть 2 варианта:
 *                      
 *                           1)    void mySubTask()
 *                                 {
 *                                     ...
 *                                     try { sleep(delay);}
 *                                     catch (InterruptedException e) {Thread.currentThread().interrupt();}
 *                                     ...
 *                                 }
 *                                     
 *                           2)    ЗДЕСЬ УБИРАЕМ БЛОК try
 *                                  void mySubTask() throws InterruptedException 
 *                                 {
 *                                     ...
 *                                     sleep(delay);
 *                                     ...
 *                                 }
 *                                 
 *            СОСТОЯНИНИЕ ПОТОКОВ
 *            
 *                       Потоки могут находиться в одном из 6 состояний:
 *                       
 *                            : новый
 *                            : исполняемый
 *                            : блокированный
 *                            : ожидающий
 *                            : временно ожидающий
 *                            : завершенный
 *                            
 *                       Чтобы опрделить текущее состояние потока, надо вызвать метод getState().
 *                       
 *                       НОВЫЙ ПОТОК
 *                       
 *                            new Thread(r)  - Поток создан, но метод start не запущен.
 *                            
 *                       ИСПОЛНЯЕМЫЕ ПОТОКИ
 *                       
 *                            start();  - Поток запущен. Состояние - исполняемый.
 *                            Поток может прерываться, для освобождения памяти, давая возможность другим потоком выполнится в порядке приоритетов.
 *                            Поэтому поток ИПОЛНЯЕМЫЙ, а не исполняющийся.
 *                            
 *                       БЛОКИРОВАННЫЕ и ОЖИДАЮЩИЕ ПОТОКИ
 *                       
 *                            : Когда поток пытается получить встроенную блокировку обьектов (раздел java.util.concurent  и synchronized)
 *                                    которая в данный момент захвачена другим потоком,  он становится блокированным.
 *                                  Поток разблокируется, когда все остальные потоки освобождают блокировку
 *                                    и планировщик потоков позволяет захватить ее данному потоку.
 *                                    
 *                            : Когда поток ожидает от другого потока уведомление планировщика о наступлении некоторого условия( раздел "ОБЬЕКТЫ УСЛОВИЙ)
 *                                    вызов метода Object.wait или Tread.join, либо в ожидании обьекта Lock или Condition 
 *                                    , то
 *                                    он входит в состояние ожидания.
 *                                    
 *                            : Несколько методов вызывают в качестве параметров время ожидания. 
 *                                    Их вызов вводит поток в состояние временного ожидания.
 *                                    Это состояние сохраняется пока не истечет заданное время ожидания или не будет получено
 *                                      соответствующее уведомление.
 *                                    Методы с временем ожидания - Object.wait(), Thread.join(), Lock.tryLock() and Condition.await().
 *                                    
 *                        ЗАВЕРШЕННЫЙ ПОТОК
 *                        
 *                        
 *                            : при естественном окончании метода run()
 *                            : при неперехватываемом исключении
 *                            
 *               СВОЙСТВА ПОТОКОВ
 *               
 *                        1) Приоритеты потоков.
 *                             У каждого потока приоритет по умолчанию = 5 (Можно установить 1..10)
 *                           По возможности не стоит злоупотреблять приоритетами.
 *                       
 *                        2) Потоковый демон.
 *                             
 *                             t.setDeamon(true); - Таким образом поток можно превратить в потокового демона.
 *                             Демон это поток у которого нету других целей, кроме как служению другим потокам.
 *                             Если остаются только потоковые демоны, виртуальная машина завершает работу.
 *                             Потоковый демон не надо использовать  к таким ресурсам как: обращение к базе данных или файлу.
 *                            
 *              СИНХРОНИЗАЦИЯ
 *              
 *                        1) "Состояние гонок". Ошибки возникающие при одновременном захвате ресурса двумя и более потоками.
 *                            
 *                        2) ОБЬЕКТЫ БЛОКИРОВКИ
 *                        
 *                                 Защита блока кода средствами класса ReenTrantLock:
 *                                 
 *                                      public Lock myLock = new ReentrantLock(); // Обьект типа ReentrantLock реализующего интерфейс Lock
 *                                 
 *                                      myLock.lock(); //  myLock Обьект типа ReentrantLock - заблокирован
 *                                      try
 *                                      {
 *                                          критический раздел кода
 *                                      }
 *                                      finally              // ВАЖНО в блоке finally разблокировать поток, 
 *                                      {                    // иначе остальные потоки будут заблокированны навсегда
 *                                          myLock.unlock(); // непременно снять блокироку, 
 *                                      }                    // даже если генерируется исключение
 *                                      
 *                                      
 *                                В пакете synch реализуется блокировка с помощью класса ReenTrantLock.
 *                                      
 *                                СЧЕТЧИК ЗАХВАТОВ ОБЬЕКТА БЛОКИРОВКИ
 *                                
 *                                       Метод в котором заблокирован обьект блокировки myLock.lock(); , может иметь
 *                                             вложенные методы в которых обьект myLock блокируется повторно. В этом случае
 *                                             счетчик захватов myLock устанавливается = 2. Следовательно UNLOCK тоже должно быть 2,
 *                                             счетчик захватов myLock вернулся к значению = 0. Тогда myLock - разблокируется.
 *                                             
 *                       ОБЪЕКТЫ УСЛОВИЙ
 *                       
 *                                С обьектом блокировки myLock может быть связан один или несколько обьектов условий
 *                          которые получены с помощью метода newCondition().
 *                       
 *                                # private Condition myCondition;
 *                                  ...
 *                                  myCondition = myLock.newCondition();
 *                                  
 *                                  Если в потоке 1 обнаружено, что условие не выполнено (например, чтобы со счета в банке надо оплатить кредит, а достаточной суммы еще пока нет)
 *                          то, делается следующий вызов:
 *                          
 *                                  muCondition.await();
 *                                  
 *                           Метод await() должен быть введен в цикл:
 *                           
 *                                  while (!(можно продолжить))
 *                                     условие.await();     
 *                                  
 *                           Теперь поток 1 деактивизирован(входит в НАБОР ОЖИДАНИЯ) и снимает блокировку,
 *                       
 *                           Условие возвражается из других потоков с помощью методов:
 *                                  
 *                                   myCondition.signalAll - активизируются все потоки исполнения, ожидающие данного условия
 *                                   
 *                                   myCondition.signal()  - активизирует один поток на выбор.
 *                                   
 *                                   
 *                           SYNCHRONIZED - ключевое слово.
 *                           
 *                                  С помощью ключевого слова можно обойтись таким образом:
 *                                  
 *                                          public synchronized void transfer(int from, int to, double amount) throws InterruptedException
                                            {
                                                   while (accounts[from] < amount)
                                                   wait();
                                                   
                                                   System.out.print(Thread.currentThread());
                                                   accounts[from] -= amount;
                                                   System.out.printf(" %10.2f from %d to %d", amount, from, to);
                                                   accounts[to] += amount;
                                                   System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
                                                   
                                                   notifyAll();
                                                   }
                                            
                                            public synchronized double getTotalBalance(){}
                                            
                                    Таким образом если есть условие, то порядок такой:
                                    
                                            synchronized метод()
                                            {
                                                while(....)
                               
                                                    wait();
                                                    ...
                                                    ...
                                                    notifyAll();
                                            }
                                            
                                     Если условия нет, то : synchronized метод(){.....}
                                     
                                     
                               БЛОКИРУЮЩИЕ ОЧЕРЕДИ
                               
                                              Блокирующая очередь это инструментальное средство управления потоками.
                                              Блокирующая очередь высокоуровневый инструмент в отличие от обьектов блокировки.
                                              
                                              МЕТОДЫ:: put(),  take(),  add(), remove(), element(), offer(), poll(), peek().
                                              
                                              BlockingQueue<File> queue = new ArrayBlockingQueue<>(FILE_QUEUE_SIZE);
 *     
 * @author IRINA
 *
 */

public class DescriptThreads {

}
