package reviewcollection;

/*
 *   РАЗДЕЛЕНИЕ ИНТЕРФЕЙСОВ И РЕАЛИЗАЦИЙ КОЛЛЕКЦИЙ.
 *   
 *           Интерфейсы и реализации разделены,
 *              это разделение происходит на примере хорошо известной структуры очереди.
 *           Интерфейс очереди определяет, что элементы можно добавлять в хвост
 *              и удалять в её голове. А также сколько элементов находится в данный момент.
 *           "Первым пришел - первым вышел".
 *           
 *           ## Пример формы интерфейса очереди из стандвартной библиотеки:
 *           
 *              interface Queue<E>
 *              {
 *                 void add(E element);
 *                 E remove();
 *                 int size();
 *              }
 *              
 *           Реалицация очереди(рис. 13.2):
 *              - циклический массив
 *              - связный список.
 *              
 *           Реализация может быть выражена классом, реализующим интерфейс:
 *           
 *              Циклический массив:
 *                                class CircularArrayQueue<E> implements Queue<E> // класс не из библиотеки
 *                                {
 *                                   CircularArrayQueue(int capacity) { . . . }
 *                                   public void add(E element) { . . . }
 *                                   public E remove(){ . . . }
 *                                   public int size(){ . . . }
 *                                   private int head;
 *                                   private int tail;
 *                                 }
 *                                 
 *              Связный список :   
 *                                 class LinkedListQueue<E> implements Queue<E> // класс не из библиотеки
 *                                 {
 *                                    LinkedListQueue(E elements) { . . . }
 *                                    public void add(E elements) { . . . }
 *                                    public E remove(){ . . . }
 *                                    public int size(){ . . . }
 *                                    private Link head;
 *                                    private Link tail;
 *                                 }
 *                                 
 *              В реальной пограммы для реализации очереди на основе:
 *                        - циклического массива, надо воспользоваться классаом из библиотеки - ArrayDeque
 *                        - связного списка, - LinkedList
 *              
 *              Класс имеет смысл использовать, если конструируется обьект коллекции.
 *              А тип интерфейса служит лишь для ссылки на коллекцию, как показано ниже:
 *                        
 *                        Queue<Customer> expressLane = new CircularArrayQueue<>(100);
 *                        expressLane.add(new Customer("Harry"));
 *               
 *              ВАЖНО. Цицлический массив(ограниченная коллекция, имеющая конечную емкость) в многом эффективнее связного списка,
 *                       НО если не известен коннечный предел колличества обьектов, которые должна накапливать программа,
 *                       ТО есть смысл выбрать связный список:
 *                       
 *                        Queue<Customer> expressLane = new LinkedListQueue<>();
 *                        expressLane.add(new Customer("Harry"));
 *                        
 *     ИНТЕРФЕЙСЫ Collection and Iterator ИЗ БИБЛИОТЕКИ Java
 *     
 *             Основной интерфейс коллекций Collection, у него есть 2 ОСНОВНЫХ метода:
 *             
 *             public interface Collection<E>
 *             {
 *                boolean add(E element); // Добавляет элемент в коллецию (true - если обьект добавлен; false - если коллекция не изменилась, допустим такой обьект уже существовал.
 *                Iterator<E> iterator(); // Возвращает обьект, реализующий интерфейс Iterator. Обьект итератора можно выбрать для обращения ко всем элементам коллекции.
 *                . . .
 *             }
 *             
 *     ИТЕРАТОРЫ
 *               В состав интерфейса Iterator входят 3 метода:
 *               
 *               public interface Iterator<E>
 *               {
 *                  E next();
 *                  boolean hasNext();
 *                  void remove();
 *               }
 *               
 *               Многократно вызывая метод next(), можно обратиться к каждому элементу коллекции по очереди. Но если будет достигнут последний элемент коллекции,
 *                  то будет выкинуто исключение NoSuchElementException.
 *               Перед обращением к элементу коллекции, следует вызвать метод hasNext(). Он возвращает true, если у обьекта итератора все ещё есть объекты к которым можно обратиться.
 *               
 *               Если требуется перебрать все элементы коллекции методом next() до тех пор пока метод hasNext() возвращает true. Ниже показана реализация:
 *               
 *                  Collection<String> c = . . .;
 *                  Iterator<String> iter = c.iterator();
 *                  while (iter.hasNext())
 *                  {
 *                     String element = iter.next();
 *                     Какое-то действие с элементом element
 *                  }
 *                  
 *               Используя for each, можно упростить код цикла:
 *                  
 *                  for (String element : c)
 *                  {
 *                      Какое-то действие с элементом element
 *                  }
 *                  
 *              Компилятор просто преобразует цикл в стиле for each в цикл с итератором.
 *              Цикл в стиле for each подходит для любых обьектов, класс которых реализует интерфейс Iterable со следующим единственным методом:
 *              
 *                 public interface Iterable<E>
 *                 {
 *                    Iterator<E> iterator();
 *                 }
 *                 
 *              Интерфейс Collection разширяет интерфейс Iterable , поэтому цикл for each подходит для любой коллекции из станд. библиотеки.
 *              Порядок, в котором перебираются элементы зависит от типа коллекции:
 *              
 *                 ДЛЯ ArrayList - по порядку, начиная с нулевого.
 *                 ДЛЯ HashSet   - в случайном порядке (например для подсчета колличества совпадений, порядок не требуется)
 *                 
 *              УДАЛЕНИЕ ЭЛЕМЕНТОВ ИЗ КОЛЛЕКЦИИ
 *              
 *              Для удаления элемента, ОБЯЗАТЕЛЬНО его пройти с помощью метода next():
 *              
 *                 Iterator<String> it = c.iterator();
 *                 it.next();
 *                 it.remove();
 *                 
 *             Обобщенные служебные методы (стр. 689 Хорстман том 2)
 *             
 *             
 *             КОНКРЕТНЫЕ КОЛЛЕКЦИИ
 *             
 *             В основном все классы коллекций реализуют интерфейс Collection,  за исключением классов оканчивающихся на Map (интерфейс Map)
 *             
 *             ArrayList  - Индексируемая динамически расширяющаяся и сокращающаяся последовательность.
 *             LinkedList - Упорядоченная последовательность, допускающая эффективную вставку и удаление на любой позиции.
 *             .......... - ........
 *             
 *             СВЯЗНЫЕ СПИСКИ, ЭФФЕКТИВНАЯ ВСТАВКА И УДАЛЕНИЕ, РЕАЛИЗАЦИЯ В ВИДЕ КЛАССА LinkedList.
 *             
 *             Пример с помощью LinkedList реализующий связный список (Добавляется 3 элемента, один удаляется):
 *             
 *                List<String> staff = new LinkedList<>();
 *                
 *                staff.add("Amy"); // Метод add() добавляет елемент в конец списка
 *                staff.add("Bob");
 *                staff.add("Carl");
 *                Iterator iter = staff.iterator();
 *                String first = iter.next();
 *                String second = iter.next();
 *                iter.remove();
 *                
 *             Добавление элемента в середину списка осуществляется с помощью интерфейса ListIterator:
 *             
 *                List<String> staff = new LinkedList<>();
 *                
 *                staff.add("Amy"); // Метод add() добавляет елемент в конец списка
 *                staff.add("Bob");
 *                staff.add("Carl");
 *                ListIterator<String> iter = staff.listIterator();
 *                iter.next();
 *                iter.add("Juliet");
 *                
 *             ВНИМАНИЕ ПРАВИЛО (при использовании несколькох итераторов для одной коллекции, может возникать ошибка видоизменения)!
 *                К коллекции допускается присоединять сколько угодно итераторов, при условии, что все они только для чтения!
 *                И только один итератор как для чтения , так и для записи.
 *                  
 *                  
 *               
 *           
 *           
 */
public class DimentionCollection {

}
